<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Buenas-Practicas on Exeal</title><link>https://www.exeal.com/tags/buenas-practicas/</link><description>Recent content in Buenas-Practicas on Exeal</description><generator>Hugo</generator><language>es</language><lastBuildDate>Tue, 27 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.exeal.com/tags/buenas-practicas/index.xml" rel="self" type="application/rss+xml"/><item><title>¿De verdad pair programming nos hace más productivos?</title><link>https://www.exeal.com/blog/2024/02/de-verdad-pair-programming-nos-hace-mas-productivos/</link><pubDate>Tue, 27 Feb 2024 00:00:00 +0000</pubDate><guid>https://www.exeal.com/blog/2024/02/de-verdad-pair-programming-nos-hace-mas-productivos/</guid><description>&lt;p>Si nunca has trabajado en pair programming, te pongo al día rápidamente: se trata de una práctica en la que &lt;strong>dos desarrolladores trabajan juntos en una única tarea, usando un único ordenador&lt;/strong>.&lt;/p>
&lt;p>Lo primero que se le viene a la mente a la gente que nunca ha trabajado con el pair programming es siempre lo mismo: &lt;em>¿Cómo va a ser más productivo dos personas trabajando en un sólo ordenador en una única tarea, cuando podrían estar cada uno con una tarea diferente y sacaríamos el doble de trabajo en el mismo tiempo?&lt;/em>&lt;/p></description></item><item><title>Entregar código a diario: Continuous Integration y Continuous Delivery</title><link>https://www.exeal.com/blog/2024/02/entregar-codigo-a-diario-continuous-integration-y-continuous-delivery/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0000</pubDate><guid>https://www.exeal.com/blog/2024/02/entregar-codigo-a-diario-continuous-integration-y-continuous-delivery/</guid><description>&lt;p>En el mundo del desarrollo de software, la capacidad de integrar y desplegar código de manera eficiente y segura es crucial. Esta práctica no solo mejora la calidad del producto final, sino que también optimiza el proceso de desarrollo. En este post, exploraremos cómo lograr integraciones y despliegues diarios seguros, profundizando en los conceptos de &lt;strong>Integración Continua (CI) y Entrega Continua (CD)&lt;/strong>, sus diferencias y objetivos.&lt;/p>
&lt;h2 id="integración-y-despliegue-diario-cómo-conseguirlo">Integración y despliegue diario: ¿Cómo conseguirlo?&lt;/h2>
&lt;p>Integrar y desplegar código a diario implica un enfoque que maximiza la seguridad y la eficiencia. Atrás quedaron los días de despliegues manuales inseguros y propensos a errores. La clave está en la &lt;strong>automatización y la estandarización de los procesos de testing y despliegue&lt;/strong>. Esto asegura que cada cambio en el código sea verificado automáticamente, reduciendo significativamente los riesgos asociados con el despliegue.&lt;/p></description></item><item><title>Cuándo es recomendable y cuándo no usar TDD</title><link>https://www.exeal.com/blog/2024/01/cuando-es-recomendable-y-cuando-no-usar-tdd/</link><pubDate>Wed, 31 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.exeal.com/blog/2024/01/cuando-es-recomendable-y-cuando-no-usar-tdd/</guid><description>&lt;p>En el mundo del desarrollo de software, la adopción de prácticas como &lt;em>Test-driven development&lt;/em> (Desarrollo dirigido por pruebas, o TDD) ha generado debates fervientes sobre su aplicabilidad universal. La premisa de alcanzar un 100% de cobertura de pruebas puede resultar atractiva, pero es crucial comprender que TDD es una herramienta, no una panacea. Aprender a discernir cuándo utilizarla de manera efectiva es fundamental para el éxito de un proyecto.&lt;/p>
&lt;h2 id="enfoque-en-el-dominio">Enfoque en el dominio&lt;/h2>
&lt;p>Uno de los principios clave al decidir cuándo emplear TDD es evaluar la proximidad al dominio de la aplicación. Las reglas de negocio, el núcleo vital que define el comportamiento del sistema, son candidatas ideales para la implementación con TDD. Aquí, la alta cobertura de pruebas y el diseño emergente aportan un valor inestimable, asegurando la robustez del código en el corazón mismo del software.&lt;/p></description></item><item><title>La base de la integración continua: los micro-commits</title><link>https://www.exeal.com/blog/2023/12/la-base-de-la-integracion-continua-los-micro-commits/</link><pubDate>Fri, 15 Dec 2023 00:00:00 +0000</pubDate><guid>https://www.exeal.com/blog/2023/12/la-base-de-la-integracion-continua-los-micro-commits/</guid><description>&lt;p>Quizá te sorprenda (a mí me sorprendió cuando empecé a &lt;a href="https://www.exeal.com/">ayudar a otros equipos como coach&lt;/a>), pero la mayoría de desarrolladores commitean código al control de versiones apenas entre 2 o 3 veces por semana.&lt;/p>
&lt;p>Esto les limita la frecuencia con la que pueden entregar código funcionando a producción.&lt;/p>
&lt;p>Cuando nuestro objetivo es incrementar la frecuencia de entrega de valor, y por tanto practicar &lt;em>trunk-based development&lt;/em>, &lt;em>continuous integration&lt;/em> y &lt;em>continuous delivery&lt;/em>, buscamos justo lo contrario: &lt;strong>acelerar la frecuencia con la que commiteamos, tanto como sea posible&lt;/strong>.&lt;/p></description></item><item><title>La deuda técnica buena</title><link>https://www.exeal.com/blog/2023/11/la-deuda-tecnica-buena/</link><pubDate>Wed, 22 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.exeal.com/blog/2023/11/la-deuda-tecnica-buena/</guid><description>&lt;p>No toda la deuda técnica es mala.&lt;/p>
&lt;p>Existe la concepción extendida (y errónea, por cierto) de que la deuda técnica es el resultado de no tener calidad, o de hacer ñapas de diseño.&lt;/p>
&lt;p>Pero no tiene nada que ver con esto.&lt;/p>
&lt;p>La &lt;strong>deuda técnica es una decisión consciente&lt;/strong>, y una muy importante &lt;strong>a nivel estratégico&lt;/strong> en un proyecto.&lt;/p>
&lt;p>En el mundo de la inversión, en el que está inspirado el concepto de deuda técnica, se habla mucho de la deuda buena y la deuda mala.&lt;/p></description></item><item><title>Práctica deliberada: una forma alternativa de aprender TDD</title><link>https://www.exeal.com/blog/2023/10/practica-deliberada-y-tdd/</link><pubDate>Tue, 31 Oct 2023 00:00:00 +0000</pubDate><guid>https://www.exeal.com/blog/2023/10/practica-deliberada-y-tdd/</guid><description>&lt;p>¿Alguna vez &lt;strong>te has estancado&lt;/strong> practicando TDD, refactoring, diseño de software o cualquier otra habilidad relacionada con la programación?&lt;/p>
&lt;p>¿Sientes que te has quedado sin katas de resolver, y que las que hay son demasiado sencillas?&lt;/p>
&lt;p>Quizá es que &lt;strong>estés practicando con el enfoque erróneo&lt;/strong>.&lt;/p>
&lt;p>Para extraer el máximo partido de practicar con katas, tenemos que emplear una técnica de práctica muy concreta: la &lt;a href="https://jamesclear.com/deliberate-practice-theory">práctica deliberada&lt;/a>.&lt;/p>
&lt;h2 id="qué-es-la-práctica-deliberada">¿Qué es la práctica deliberada?&lt;/h2>
&lt;p>La práctica deliberada &lt;strong>es un método para practicar cualquier habilidad&lt;/strong>, especialmente aquellas que requieran repetición para dominar una técnica. Consiste en:&lt;/p></description></item><item><title>Cómo escribir el primer test usando TDD</title><link>https://www.exeal.com/blog/2023/10/como-escribir-el-primer-test-usando-tdd/</link><pubDate>Wed, 25 Oct 2023 00:00:00 +0000</pubDate><guid>https://www.exeal.com/blog/2023/10/como-escribir-el-primer-test-usando-tdd/</guid><description>&lt;p>El primer test es uno de los pasos más importantes cuando desarrollamos TDD. Es el que va a determinar si construimos nuestra solución sobre unos cimientos sólidos o nos vamos a complicar la vida innecesariamente.&lt;/p>
&lt;p>Hay tres cosas principales que yo le pido a mi primer test:&lt;/p>
&lt;ol>
&lt;li>La primera, que ponga sobre la mesa los elementos más importantes que van a entrar en juego, o las entradas y salidas del sistema (a.k.a. el “given” más sencillo)&lt;/li>
&lt;li>La segunda, que me defina cómo voy a interactuar con el sistema, la fachada del mismo, i.e. cuál es la interfaz pública de mi módulo o clase (a.k.a. el “when” más sencillo”).&lt;/li>
&lt;li>Tercera, que capture el comportamiento del caso más simple que involucre a todos los elementos, o las salidas y entradas más sencillas (a.k.a. el “then” más sencillo).&lt;/li>
&lt;/ol>
&lt;p>Lo que busco con esto es definir las interfaces de todas las piezas que van a entrar en juego, y hacerlas funcionar lo antes posible con un caso muy sencillo, para que luego sea más fácil hacer crecer la solución de forma incremental añadiendo más tests.&lt;/p></description></item><item><title>¿Quién debería escribir las historias de usuario?</title><link>https://www.exeal.com/blog/2023/10/quien-deberia-escribir-las-historias-de-usuario/</link><pubDate>Tue, 24 Oct 2023 00:00:00 +0000</pubDate><guid>https://www.exeal.com/blog/2023/10/quien-deberia-escribir-las-historias-de-usuario/</guid><description>&lt;p>¿Quién escribe las historias de usuario? ¿El Product Owner? ¿El Product Manager? ¿El propio equipo?&lt;/p>
&lt;p>Es una pregunta que sale de forma recurrente en los equipos. En la mayoría, es algo que hace el Product Owner. Es la única perspectiva que los desarrolladores tienen sobre &amp;ldquo;lo que pide&amp;rdquo; el cliente. Un documento de requisitos escrito por un proxy de un proxy del cliente, con el que jugamos al teléfono roto.&lt;/p></description></item><item><title>Cómo dividir los requisitos para entregar valor de forma continua: Vertical Slicing</title><link>https://www.exeal.com/blog/2023/10/como-dividir-los-requisitos-para-entregar-valor-de-forma-continua-vertical-slicing/</link><pubDate>Tue, 17 Oct 2023 00:00:00 +0000</pubDate><guid>https://www.exeal.com/blog/2023/10/como-dividir-los-requisitos-para-entregar-valor-de-forma-continua-vertical-slicing/</guid><description>&lt;p>Cuando trabajamos en un proyecto software de cierto tamaño, tenemos que dividir (hacer slicing, o &amp;ldquo;loncheado&amp;rdquo;) los requisitos más grandes en tareas más pequeñas y abordables.&lt;/p>
&lt;p>Existen dos formas de hacer esta división: slicing horizontal y vertical.&lt;/p>
&lt;p>Cuando hacemos &lt;em>horizontal slicing&lt;/em>, dividimos por un criterio técnico (normalmente capas). Hacemos una tarea para el front, otra para el back, otra para la base de datos, etc.&lt;/p>
&lt;p>Este enfoque nos plantea 2 problemas&lt;/p></description></item><item><title>Slack: cómo ganar predictibilidad, agilidad y construir un ritmo sostenible</title><link>https://www.exeal.com/blog/2023/07/slack-como-ganar-predictibilidad-agilidad-y-ritmo-sostenible/</link><pubDate>Thu, 20 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.exeal.com/blog/2023/07/slack-como-ganar-predictibilidad-agilidad-y-ritmo-sostenible/</guid><description>&lt;h2 id="una-historia-de--mensajería">Una historia de … ¿mensajería?&lt;/h2>
&lt;p>Permíteme que te presente al equipo de Messaging de la empresa Drocsid Inc. El equipo de Messaging viene arrastrando un problema durante los últimos meses: en las últimas iteraciones de producto vienen sistemáticamente fallando al entregar todas las historias con las que se comprometieron al principio de la iteración. En cada &lt;em>sprint review&lt;/em> se repite la misma situación: el equipo excusándose en que los inconvenientes del &lt;em>business as usual&lt;/em> (esas tareas operativas que no podemos evitar, como resolver incidencias, dar soporte, despliegues, etc.) les han impedido acabar con todos los compromisos de la iteración; de que no tienen tiempo para dedicar a la mejora técnica y de procesos que necesitan para poder ser más predecibles; stakeholders decepcionados porque contaban con que el equipo entregaría esas funcionalidades, y la percepción por parte de management de que &lt;strong>el equipo está no está rindiendo lo suficiente&lt;/strong>.&lt;/p></description></item><item><title>Mob programming</title><link>https://www.exeal.com/blog/2021/10/mob-programming/</link><pubDate>Tue, 26 Oct 2021 00:10:00 +0100</pubDate><guid>https://www.exeal.com/blog/2021/10/mob-programming/</guid><description>&lt;h2 id="mob-programming">Mob programming&lt;/h2>
&lt;p>¡Hola! ¿cómo estan? Espero que muy bien, Soy Damián 👋, Technical Coach en &lt;a href="https://www.exeal.com/">Exeal&lt;/a>, y en esta oportunidad me gustaría explicarles brevemente como funciona esta dinámica que llevamos a diario en &lt;a href="https://www.exeal.com/">Exeal&lt;/a>&lt;/p>
&lt;p>Desde mi punto de vista, &lt;strong>Mob Programming&lt;/strong> es una de las mejores prácticas que debe tener cualquier desarrollador de software dentro de su toolkit; no solo por los resultados evidentes de esta dinámica, como el conocimiento colectivo y la calidad de código que aportamos al momento de realizarlo, sino porque además nos enseña implícitamente a escuchar, hablar y respetar a nuestros compañeros de equipo.&lt;/p></description></item></channel></rss>