<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Best-Practices on Exeal</title><link>https://www.exeal.com/tags/best-practices/</link><description>Recent content in Best-Practices on Exeal</description><generator>Hugo</generator><language>es</language><lastBuildDate>Tue, 27 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.exeal.com/tags/best-practices/index.xml" rel="self" type="application/rss+xml"/><item><title>¿De verdad pair programming nos hace más productivos?</title><link>https://www.exeal.com/blog/2024/02/de-verdad-pair-programming-nos-hace-mas-productivos/</link><pubDate>Tue, 27 Feb 2024 00:00:00 +0000</pubDate><guid>https://www.exeal.com/blog/2024/02/de-verdad-pair-programming-nos-hace-mas-productivos/</guid><description>&lt;p>Si nunca has trabajado en pair programming, te pongo al día rápidamente: se trata de una práctica en la que &lt;strong>dos desarrolladores trabajan juntos en una única tarea, usando un único ordenador&lt;/strong>.&lt;/p>
&lt;p>Lo primero que se le viene a la mente a la gente que nunca ha trabajado con el pair programming es siempre lo mismo: &lt;em>¿Cómo va a ser más productivo dos personas trabajando en un sólo ordenador en una única tarea, cuando podrían estar cada uno con una tarea diferente y sacaríamos el doble de trabajo en el mismo tiempo?&lt;/em>&lt;/p></description></item><item><title>Entregar código a diario: Continuous Integration y Continuous Delivery</title><link>https://www.exeal.com/blog/2024/02/entregar-codigo-a-diario-continuous-integration-y-continuous-delivery/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0000</pubDate><guid>https://www.exeal.com/blog/2024/02/entregar-codigo-a-diario-continuous-integration-y-continuous-delivery/</guid><description>&lt;p>En el mundo del desarrollo de software, la capacidad de integrar y desplegar código de manera eficiente y segura es crucial. Esta práctica no solo mejora la calidad del producto final, sino que también optimiza el proceso de desarrollo. En este post, exploraremos cómo lograr integraciones y despliegues diarios seguros, profundizando en los conceptos de &lt;strong>Integración Continua (CI) y Entrega Continua (CD)&lt;/strong>, sus diferencias y objetivos.&lt;/p>
&lt;h2 id="integración-y-despliegue-diario-cómo-conseguirlo">Integración y despliegue diario: ¿Cómo conseguirlo?&lt;/h2>
&lt;p>Integrar y desplegar código a diario implica un enfoque que maximiza la seguridad y la eficiencia. Atrás quedaron los días de despliegues manuales inseguros y propensos a errores. La clave está en la &lt;strong>automatización y la estandarización de los procesos de testing y despliegue&lt;/strong>. Esto asegura que cada cambio en el código sea verificado automáticamente, reduciendo significativamente los riesgos asociados con el despliegue.&lt;/p></description></item><item><title>Cuándo es recomendable y cuándo no usar TDD</title><link>https://www.exeal.com/blog/2024/01/cuando-es-recomendable-y-cuando-no-usar-tdd/</link><pubDate>Wed, 31 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.exeal.com/blog/2024/01/cuando-es-recomendable-y-cuando-no-usar-tdd/</guid><description>&lt;p>En el mundo del desarrollo de software, la adopción de prácticas como &lt;em>Test-driven development&lt;/em> (Desarrollo dirigido por pruebas, o TDD) ha generado debates fervientes sobre su aplicabilidad universal. La premisa de alcanzar un 100% de cobertura de pruebas puede resultar atractiva, pero es crucial comprender que TDD es una herramienta, no una panacea. Aprender a discernir cuándo utilizarla de manera efectiva es fundamental para el éxito de un proyecto.&lt;/p>
&lt;h2 id="enfoque-en-el-dominio">Enfoque en el dominio&lt;/h2>
&lt;p>Uno de los principios clave al decidir cuándo emplear TDD es evaluar la proximidad al dominio de la aplicación. Las reglas de negocio, el núcleo vital que define el comportamiento del sistema, son candidatas ideales para la implementación con TDD. Aquí, la alta cobertura de pruebas y el diseño emergente aportan un valor inestimable, asegurando la robustez del código en el corazón mismo del software.&lt;/p></description></item></channel></rss>