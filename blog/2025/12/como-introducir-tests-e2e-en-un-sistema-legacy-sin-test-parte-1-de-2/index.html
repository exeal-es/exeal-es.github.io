<!doctype html><html lang=es><head><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-TQGN65PV")</script><meta charset=utf-8><title>Cómo introducir tests E2E en un sistema legacy sin tests (parte 1/2) | Exeal</title>
<meta name=description content="Un enfoque pragmático para introducir tests E2E en un backend legacy sin tests: refactors atómicos, arquitectura hexagonal y control del riesgo en producción."><meta name=author content="Exeal"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:url" content="https://www.exeal.com/blog/2025/12/como-introducir-tests-e2e-en-un-sistema-legacy-sin-test-parte-1-de-2/"><meta property="og:site_name" content="Exeal"><meta property="og:title" content="Cómo introducir tests E2E en un sistema legacy sin tests (parte 1/2)"><meta property="og:description" content="Un enfoque pragmático para introducir tests E2E en un backend legacy sin tests: refactors atómicos, arquitectura hexagonal y control del riesgo en producción."><meta property="og:locale" content="es"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-12-27T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-27T00:00:00+00:00"><meta property="article:tag" content="Legacy"><meta property="article:tag" content="Testing"><meta property="article:tag" content="Arquitectura"><meta property="og:image" content="https://www.exeal.com/images/blog/posts/programador.jpg"><meta itemprop=name content="Cómo introducir tests E2E en un sistema legacy sin tests (parte 1/2)"><meta itemprop=description content="Un enfoque pragmático para introducir tests E2E en un backend legacy sin tests: refactors atómicos, arquitectura hexagonal y control del riesgo en producción."><meta itemprop=datePublished content="2025-12-27T00:00:00+00:00"><meta itemprop=dateModified content="2025-12-27T00:00:00+00:00"><meta itemprop=wordCount content="3092"><meta itemprop=image content="https://www.exeal.com/images/blog/posts/programador.jpg"><meta itemprop=keywords content="Legacy,Testing,Arquitectura"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.exeal.com/images/blog/posts/programador.jpg"><meta name=twitter:title content="Cómo introducir tests E2E en un sistema legacy sin tests (parte 1/2)"><meta name=twitter:description content="Un enfoque pragmático para introducir tests E2E en un backend legacy sin tests: refactors atómicos, arquitectura hexagonal y control del riesgo en producción."><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><link rel=stylesheet href=https://www.exeal.com/scss/main.css><link rel=stylesheet href=https://www.exeal.com/scss/hero.css><link rel=icon type=image/png href=/assets/img/favicon.png><link rel=apple-touch-icon href=/assets/img/apple-touch-icon.png><script type=text/javascript id=hs-script-loader async defer src=//js.hs-scripts.com/8231847.js></script><link rel=stylesheet type=text/css href=https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.css><meta name=facebook-domain-verification content="xwbugjbpmp2jwy1y6mzdhe6ga267uz"><script>!function(e,t,n,s,o,i,a){if(e.fbq)return;o=e.fbq=function(){o.callMethod?o.callMethod.apply(o,arguments):o.queue.push(arguments)},e._fbq||(e._fbq=o),o.push=o,o.loaded=!0,o.version="2.0",o.queue=[],i=t.createElement(n),i.async=!0,i.src=s,a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(i,a)}(window,document,"script","https://connect.facebook.net/en_US/fbevents.js"),fbq("init","417415780749470"),fbq("track","PageView")</script><noscript><img height=1 width=1 style=display:none src="https://www.facebook.com/tr?id=417415780749470&ev=PageView&noscript=1"></noscript><script>(function(e,t,n,s,o,i){e.hj=e.hj||function(){(e.hj.q=e.hj.q||[]).push(arguments)},e._hjSettings={hjid:5031744,hjsv:6},o=t.getElementsByTagName("head")[0],i=t.createElement("script"),i.async=1,i.src=n+e._hjSettings.hjid+s+e._hjSettings.hjsv,o.appendChild(i)})(window,document,"https://static.hotjar.com/c/hotjar-",".js?sv=")</script><link rel=stylesheet href=https://www.exeal.com/scss/blog.css><link rel=stylesheet href=https://www.exeal.com/scss/hero.css></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-TQGN65PV" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><nav class="navbar navbar-light navbar-expand-lg navbar-shrink"><div class=container><div class="d-flex flex-row"><a href=/ class=navbar-brand><img src=/assets/img/logo-exeal-header-black.svg alt=Exeal>
</a><a href=/blog/ class=navbar-brand><img src=/assets/img/blog/logo-blog.svg alt=Blog></a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarTogglerDemo01 aria-controls=navbarTogglerDemo01 aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarTogglerDemo01><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/eventos/>Próximos Eventos</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownrecursos role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Recursos</a><div class=dropdown-menu aria-labelledby=navbarDropdownrecursos><a class=dropdown-item href=/recursos/checklist-equipos-de-alto-rendimiento/>Equipos de alto rendimiento</a>
<a class=dropdown-item href=/recursos/habla-el-idioma-del-negocio/>Habla el idioma del negocio</a>
<a class=dropdown-item href=/hacia-la-excelencia/>Comunidad de práctica</a>
<a class=dropdown-item href=/katas/>Katas de programación</a>
<a class=dropdown-item href=/blog/>Blog</a></div></li><li class=nav-item><a class="nav-link nav-button" href=/>Cursos</a></li></ul></div></div></nav><header class="hero hero-bg-img" style=background-image:url(/images/blog/posts/programador.jpg)><div class="hero-bg-img-mask bg-mask"><div class="container h-100"><div class="row h-100 align-items-center"><div class="col-12 text-center"><ul class="tags tags-light"><li><a href=https://www.exeal.com/tags/legacy/>#legacy</a></li><li><a href=https://www.exeal.com/tags/testing/>#testing</a></li><li><a href=https://www.exeal.com/tags/arquitectura/>#arquitectura</a></li></ul><h1><span class=underline>Cómo introducir tests E2E en un sistema legacy sin tests (parte 1/2)</span></h1><h2>Pedro Pardal</h2><p class=date>2025/12/27</p><p><a data-scroll=sect-body href=#><img class=arrow-down src=/assets/img/arrow-down-secondary.svg></a></p></div></div></div></div></header><section id=sect-body><div class=container><article><p>Hay sistemas en los que tocar código da respeto. Y luego están aquellos en los que tocar código <strong>da miedo de verdad</strong>: flujos críticos, dinero real, integraciones externas y cero red de seguridad.</p><p>Este era uno de esos casos.</p><p>Un e-commerce en Symfony, con años de evolución y mucha lógica de negocio acumulada. El sistema funcionaba, pero no había ningún tipo de tests automatizados. Ni unitarios. Ni de integración. Ni end-to-end. Cada cambio relevante se hacía con testing manual y mucha cautela.</p><p>Para fixes pequeños y locales, el enfoque aguantaba. Pero en cuanto el cambio tocaba un flujo crítico —creación de pedidos, sincronización con plataformas externas, reglas de negocio complejas— el riesgo se disparaba. Ahí el testing manual dejaba de escalar y no había forma real de saber si un refactor había roto algo sutil.</p><p>Ese es el punto en el que “no tener tests” deja de ser una cuestión técnica y se convierte en un <strong>riesgo de negocio</strong>.</p><hr><h2 id=antes-de-escribir-tests-había-que-entender-el-sistema>Antes de escribir tests, había que <em>entender el sistema</em></h2><p>El primer error habría sido lanzarse a escribir tests sin entender el comportamiento real del sistema. Antes de eso, fue necesario dar un paso previo: <strong>añadir observabilidad básica</strong>. Logs estructurados, contexto compartido y la trazabilidad mínima para poder seguir un pedido de principio a fin.</p><p>Ese trabajo no se hizo pensando todavía en tests. Se hizo para <strong>entender el sistema</strong>. De hecho, todo ese proceso lo cuento con más detalle en el <a href=/blog/2025/12/como-meti-observabilidad-y-una-red-de-seguridad-real-en-un-backend-legacy-sin-tests-sin-romper-produccion/>post anterior</a>. Sin esa capa previa, lo que vino después simplemente no habría sido posible.</p><p>La observabilidad permitió empezar a responder preguntas simples pero fundamentales:</p><ul><li>¿Dónde empieza realmente este flujo?</li><li>¿Qué servicios participan?</li><li>¿Qué decisiones se toman y en qué orden?</li></ul><p>Hasta ese momento, muchas de esas respuestas solo existían “más o menos” en la cabeza de alguien o enterradas en el código. Sin esa visibilidad previa, cualquier intento de escribir tests habría sido poco más que una <strong>ilusión de control</strong>: tests que pasan, pero que no protegen nada importante.</p><hr><h2 id=el-error-habitual-empezar-por-el-tipo-de-test-equivocado>El <em>error habitual</em>: empezar por el tipo de test equivocado</h2><p>En sistemas sin tests, es tentador empezar por unit tests y “limpiar” diseño poco a poco. Aquí eso no era realista:</p><ul><li>El código no estaba diseñado para testear unidades aisladas.</li><li>El coste inicial era enorme.</li><li>El valor inmediato para el negocio era bajo.</li><li>Y el riesgo, alto.</li></ul><p>Así que se tomó una decisión consciente: <strong>no íbamos a validar cómo debería funcionar el sistema, sino cómo funciona ahora mismo</strong>.</p><p>Eso nos llevaba directamente a <strong>tests de caracterización</strong>.</p><hr><h2 id=tests-de-caracterización-el-comportamiento-actual-como-contrato>Tests de caracterización: el <em>comportamiento actual</em> como contrato</h2><p>Un test de caracterización asume algo muy concreto:</p><blockquote><p>El comportamiento actual del sistema es el contrato que hay que proteger.</p></blockquote><p>No se juzga si es elegante ni si está bien diseñado. Se captura tal cual. El objetivo no es expresar intención, sino detectar cambios.</p><p>La pregunta que responde el test no es <em>“¿esto está bien?”</em>, sino:</p><blockquote><p><em>“¿esto sigue haciendo lo mismo que ayer?”</em></p></blockquote><p>Para un sistema legacy en producción, ese cambio de enfoque es clave.</p><hr><h2 id=elegir-un-solo-flujo-crítico>Elegir <em>un solo</em> flujo crítico</h2><p>Aquí es fácil equivocarse queriendo cubrir demasiado pronto. En lugar de eso, se eligió <strong>un único flujo</strong>, el más sensible:</p><ul><li>atraviesa muchas capas,</li><li>depende de integraciones externas,</li><li>y su fallo impacta directamente en negocio.</li></ul><p>Concretamente: <strong>el flujo completo de creación y sincronización de un pedido</strong> desde una plataforma externa hasta el core del sistema.</p><p>Ese flujo sería el primer test E2E. Nada más.</p><hr><h2 id=primer-choque-técnico-el-flujo-no-era-ejecutable-desde-un-test>Primer choque técnico: el flujo <em>no era ejecutable</em> desde un test</h2><p>El primer intento de ejecutar ese flujo desde PHPUnit dejó claro el problema principal: el sistema <strong>no estaba pensado para ser invocado desde un test</strong>. La lógica de negocio vivía mezclada con demasiadas cosas que no le correspondían: validación HTTP, parsing de requests, detalles del webhook y decisiones de infraestructura. Todo eso hacía que el flujo solo pudiera ejecutarse en un contexto “real”, nunca bajo control.</p><p>En la práctica, el punto de entrada del flujo era algo así:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ShopifyWebhookController</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>AbstractController</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[Route(&#39;/shopify/orders/create&#39;, methods: [&#39;POST&#39;])]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>shopifyWebhookOrderCreate</span>(<span style=color:#a6e22e>Request</span> $request)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Response</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Validación del webhook (headers, firmas, etc.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Parsing de la request HTTP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Manejo de errores de protocolo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Lógica de negocio embebida:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// - crear o actualizar el pedido
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// - disparar procesamiento
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// - aplicar reglas
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Aquí el problema no era solo la falta de tests, sino que <strong>el caso de uso estaba secuestrado por la infraestructura</strong>. Para ejecutar la lógica de negocio tenías que pasar por HTTP, por Symfony, por el runtime completo. Desde un test, eso es una pesadilla.</p><p>El primer paso técnico fue <strong>hacer explícito el punto de entrada del flujo</strong>, sin reescribir la lógica y sin cambiar comportamiento. Solo separarla.</p><p>La lógica de negocio se extrajo a un servicio de aplicación invocable directamente:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ShopifyWebhookListener</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>onOrderCreated</span>(<span style=color:#66d9ef>array</span> $orderData)<span style=color:#f92672>:</span> <span style=color:#a6e22e>void</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Lógica de negocio pura:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// - interpretar el pedido
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// - aplicar reglas
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// - persistir cambios
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// - disparar procesos posteriores
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>El controller pasó a ser simplemente un adaptador:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ShopifyWebhookController</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>AbstractController</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>shopifyWebhookOrderCreate</span>(<span style=color:#a6e22e>Request</span> $request)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Response</span> {
</span></span><span style=display:flex><span>        $orderData <span style=color:#f92672>=</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>parseRequest</span>($request);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>shopifyWebhookListener</span><span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>onOrderCreated</span>($orderData);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Response</span>(<span style=color:#e6db74>&#39;OK&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Este cambio es pequeño, pero decisivo. No se ha reescrito la lógica, no se ha cambiado el comportamiento del sistema. Lo único que ha cambiado es que ahora <strong>el caso de uso tiene un punto de entrada claro</strong>, invocable tanto desde HTTP como desde un test.</p><p>Conceptualmente, esta separación viene directamente de <a href=https://academia.exeal.com/courses/masterclass-arquitectura-hexagonal><strong>arquitectura hexagonal</strong></a>: el controller es un adaptador de entrada y el servicio de aplicación actúa como <strong>puerto primario</strong>. El flujo ya no depende de cómo llega la petición, sino de qué se quiere hacer.</p><p>Y ese detalle marca la diferencia. A partir de aquí, el flujo puede ejecutarse bajo control desde PHPUnit, sin HTTP, sin webhooks reales y sin infraestructura innecesaria.</p><hr><h2 id=dejar-que-el-test-falle-para-saber-qué-aislar>Dejar que el test falle para saber <em>qué aislar</em></h2><p>Una vez el flujo tenía un punto de entrada claro y podía invocarse desde un test, llegó el siguiente choque con la realidad: <strong>el test no avanzaba ni dos pasos sin romperse</strong>.</p><p>Y eso era exactamente lo que tenía que pasar.</p><p>Cada fallo no era un problema, era una señal. El test estaba haciendo visible algo que antes estaba implícito: qué partes del flujo dependían directamente del mundo exterior y, por tanto, no podían controlarse desde un entorno de test.</p><p>Los primeros fallos eran siempre del mismo tipo:</p><ul><li>llamadas directas a APIs externas,</li><li>clientes SDK instanciados dentro del método,</li><li><code>curl</code> o <code>HttpClient</code> invocados inline,</li><li>servicios que asumían red, credenciales o estado real.</li></ul><p>Por ejemplo, cosas de este estilo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ShopifyWebhookListener</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>onOrderCreated</span>(<span style=color:#66d9ef>array</span> $orderData)<span style=color:#f92672>:</span> <span style=color:#a6e22e>void</span> {
</span></span><span style=display:flex><span>        $shopifyOrder <span style=color:#f92672>=</span> (<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ShopifySDK</span>())<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>Order</span>($orderData[<span style=color:#e6db74>&#39;id&#39;</span>]);
</span></span><span style=display:flex><span>        $paymentInfo <span style=color:#f92672>=</span> <span style=color:#a6e22e>PaypalServerSdkClientBuilder</span><span style=color:#f92672>::</span><span style=color:#a6e22e>init</span>()<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>getPaymentsController</span>()<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>getAuthorizedPayment</span>($orderData[<span style=color:#e6db74>&#39;payment_id&#39;</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// lógica de negocio a partir de datos externos
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Desde producción esto funciona.</p><p>Desde un test E2E, es <strong>incontrolable</strong>.</p><h3 id=no-aislar-todo-solo-lo-que-el-test-necesita>No aislar “todo”, solo lo que el test necesita</h3><p>Aquí es donde es fácil pasarse de frenada y empezar a “hexagonalizar” todo el sistema. No era el objetivo. La idea no era rediseñar la arquitectura, sino <strong>hacer el flujo testeable lo justo</strong>.</p><p>La regla es muy simple:</p><blockquote><p><em>&ldquo;Solo se aísla aquello que hace que el test no pueda avanzar.&rdquo;</em></p></blockquote><p>Nada más.</p><p>Cada vez que el test fallaba por una dependencia externa, se introducía un punto de aislamiento <strong>en ese punto exacto</strong>, no antes.</p><p>Siguiendo con el ejemplo anterior, el cambio fue algo así:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ShopifyOrders</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getOrder</span>(<span style=color:#a6e22e>string</span> $orderId)<span style=color:#f92672>:</span> <span style=color:#66d9ef>array</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Payments</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>fetchPayment</span>(<span style=color:#a6e22e>string</span> $paymentId)<span style=color:#f92672>:</span> <span style=color:#66d9ef>array</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Y el servicio pasó a depender de interfaces:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ShopifyWebhookListener</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> __construct(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>ShopifyOrders</span> $shopifyOrders,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Payments</span> $payments,
</span></span><span style=display:flex><span>    ) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>onOrderCreated</span>(<span style=color:#66d9ef>array</span> $orderData)<span style=color:#f92672>:</span> <span style=color:#a6e22e>void</span> {
</span></span><span style=display:flex><span>        $shopifyOrder <span style=color:#f92672>=</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>shopifyOrders</span><span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>getOrder</span>($orderData[<span style=color:#e6db74>&#39;id&#39;</span>]);
</span></span><span style=display:flex><span>        $paymentInfo <span style=color:#f92672>=</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>payments</span><span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>fetchPayment</span>($orderData[<span style=color:#e6db74>&#39;payment_id&#39;</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// lógica de negocio
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>En producción, esas interfaces se conectan a adapters reales.
En tests, a fakes controlados.</p><h3 id=qué-pinta-tiene-un-fake-controlado-y-cómo-se-usa-en-el-test>¿Qué pinta tiene un <em>fake</em> controlado (y cómo se usa en el test)?</h3><p>Una vez introduces interfaces en los puntos justos, el siguiente paso natural es <strong>reemplazar las dependencias externas por fakes controlados</strong>. No mocks llenos de expectativas, sino <a href=https://www.ppardalj.com/newsletter/2025/06/por-que-los-mocks-hacen-tus-tests-mas-fragiles-y-que-usar-en-su-lugar/>implementaciones simples que devuelven datos predecibles</a>.</p><p>Un <em>fake</em> controlado suele ser algo así: una clase en memoria, sin red ni IO, que puedes programar explícitamente desde el test.</p><p>Ejemplo esquemático:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FakeShopifyOrders</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>ShopifyOrders</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>array</span> $orders <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>withOrder</span>(<span style=color:#a6e22e>string</span> $id, <span style=color:#66d9ef>array</span> $order)<span style=color:#f92672>:</span> <span style=color:#a6e22e>self</span> {
</span></span><span style=display:flex><span>        $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>orders</span>[$id] <span style=color:#f92672>=</span> $order;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $this;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getOrder</span>(<span style=color:#a6e22e>string</span> $orderId)<span style=color:#f92672>:</span> <span style=color:#66d9ef>array</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>orders</span>[$orderId];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>No hay magia. No hay expectativas implícitas.
Solo datos controlados.</p><p>En el test, el uso es igual de explícito:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$shopify <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>FakeShopifyOrders</span>();
</span></span><span style=display:flex><span>$shopify<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>withOrder</span>(<span style=color:#e6db74>&#39;order-123&#39;</span>, $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>sampleOrder</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$listener <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ShopifyWebhookListener</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>shopifyOrders</span><span style=color:#f92672>:</span> $shopify,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// resto de dependencias
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$listener<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>onOrderCreated</span>($orderData);
</span></span></code></pre></div><p>Este tipo de fake te da tres cosas clave:</p><ul><li>control total sobre el escenario,</li><li>cero dependencia del exterior,</li><li>y una lectura muy clara del test.</li></ul><p>El test no dice <em>“espero que se llame a X”</em>.
Dice <em>“dado este mundo, cuando ejecuto el flujo, el sistema se comporta así”</em>.</p><p>Y eso es exactamente lo que necesitas cuando estás caracterizando un sistema legacy.</p><h3 id=interfaces-cerca-del-io-aunque-no-sea-clean>Interfaces cerca del IO (aunque no sea “clean”)</h3><p>Aquí hay una decisión importante que conviene hacer explícita, porque es fácil juzgarla desde fuera.</p><p>Las interfaces <strong>no</strong> se colocaron en el core más puro posible. En muchos casos se colocaron <strong>muy cerca del IO</strong>, incluso delante de llamadas <code>curl</code> o SDKs externos.</p><p>Por ejemplo, en vez de envolver todo un cliente SDK enorme, se aisló justo el punto que hacía la llamada externa:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>KlarnaHttpClient</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>KlarnaGateway</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>requestPayment</span>(<span style=color:#66d9ef>array</span> $payload)<span style=color:#f92672>:</span> <span style=color:#66d9ef>array</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// llamada curl directa
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>¿Es arquitectura hexagonal “de libro”?
No.</p><p>¿Es efectiva para testear un legacy real sin reescribirlo entero?
Sí.</p><p>El criterio fue siempre el mismo: <strong>maximizar control en tests con el menor movimiento posible</strong>.</p><h3 id=el-test-como-motor-del-diseño>El test como motor del diseño</h3><p>Lo interesante de este proceso es que <strong>no hubo un diseño previo</strong>. El diseño emergió a partir de los fallos del test.</p><p>El ciclo fue siempre el mismo:</p><ol><li>Ejecutar el test.</li><li>Ver dónde falla.</li><li>Preguntarse: “¿esto depende del exterior?”</li><li>Introducir una interfaz mínima.</li><li>Repetir.</li></ol><p>Esto encaja perfectamente con la idea de arquitectura hexagonal aplicada de forma pragmática: los <strong>puertos secundarios</strong> aparecen cuando el dominio necesita hablar con algo externo, no antes.</p><p>No se trata de imponer una arquitectura, sino de <strong>dejar que el sistema la vaya pidiendo</strong>.</p><h3 id=qué-se-gana-con-este-enfoque>Qué se gana con este enfoque</h3><p>Después de aislar las dependencias mínimas necesarias, el test empezó a avanzar de verdad. Y con ello aparecieron varias ventajas claras:</p><ul><li>el flujo podía ejecutarse completo sin tocar red,</li><li>las integraciones externas quedaban bajo control,</li><li>el core de negocio empezaba a ser invocable en aislamiento,</li><li>y el diseño mejoraba <strong>como efecto secundario</strong>, no como objetivo.</li></ul><p>Todavía no estábamos validando resultados.
Todavía no había asserts.</p><p>Pero el sistema ya había cruzado una frontera importante:
<strong>el comportamiento crítico podía ejecutarse dentro de un test sin depender del mundo exterior</strong>.</p><hr><h2 id=la-parte-más-peligrosa-refactorizar-sin-red-todavía>La parte más peligrosa: refactorizar sin red (todavía)</h2><p>Aquí viene la realidad que en muchos posts se barre bajo la alfombra: durante buena parte del proceso <strong>aún no había tests que nos protegieran</strong>. Estábamos refactorizando precisamente para poder llegar a ese primer test E2E… lo cual significa que cada cambio tenía que hacerse como si estuvieras operando a corazón abierto.</p><p>La única forma de que esto fuera viable fue imponer una disciplina extremadamente conservadora: <strong>refactors atómicos</strong>, uno a uno, y <strong>validación manual entre pasos</strong>. No “gran refactor”, no “ya que estoy aquí”. Cirugía.</p><p>La regla era simple:</p><blockquote><p>Cada commit debía poder explicarse como “misma lógica, diferente forma”.
Y después de cada paso, había que comprobar manualmente que el flujo seguía funcionando.</p></blockquote><h3 id=qué-significa-refactor-atómico-en-la-práctica>Qué significa “refactor atómico” en la práctica</h3><p>En vez de tocar diez cosas a la vez, el trabajo se descompuso en transformaciones pequeñas, típicamente asistidas por el IDE:</p><ul><li><strong>Extract Method</strong>: sacar un bloque con nombre, sin cambiar comportamiento.</li><li><strong>Extract Class</strong>: mover métodos enteros a otra clase.</li><li><strong>Extract Interface</strong>: introducir un contrato delante de una dependencia externa.</li><li><strong>Introduce Parameter / Dependency</strong>: pasar una dependencia como argumento (o por constructor) en vez de instanciarla inline.</li><li><strong>Move Method / Rename</strong>: clarificar sin alterar la lógica.</li><li><strong>Inline</strong> (a veces): eliminar capas falsas que estorbaban al siguiente paso.</li></ul><p>El orden importaba. Primero hacer el código “movible”, luego introducir seams (interfaces), y solo entonces empezar a fakear dependencias en tests.</p><p>Ejemplo esquemático de cómo se veía ese camino:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#75715e>// Paso 1: Extract Method (sin cambiar nada)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>fetchExternalOrder</span>(<span style=color:#a6e22e>string</span> $orderId)<span style=color:#f92672>:</span> <span style=color:#66d9ef>array</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>shopifySdk</span><span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>getOrder</span>($orderId);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Paso 2: Extract Interface (mismo comportamiento)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ExternalOrders</span> { <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getOrder</span>(<span style=color:#a6e22e>string</span> $orderId)<span style=color:#f92672>:</span> <span style=color:#66d9ef>array</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Paso 3: Adapter (mismo IO, pero detrás de interfaz)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ShopifyExternalOrders</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>ExternalOrders</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> __construct(<span style=color:#66d9ef>private</span> <span style=color:#a6e22e>ShopifySdk</span> $sdk) {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getOrder</span>(<span style=color:#a6e22e>string</span> $orderId)<span style=color:#f92672>:</span> <span style=color:#66d9ef>array</span> { <span style=color:#66d9ef>return</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>sdk</span><span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>getOrder</span>($orderId); }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Paso 4: Inyección (ahora testeable)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderProcessor</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> __construct(<span style=color:#66d9ef>private</span> <span style=color:#a6e22e>ExternalOrders</span> $orders) {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nada de esto “añade features”. Solo crea puntos de acoplamiento controlables.</p><h3 id=manual-testing-como-guardrail-temporal>Manual testing como guardrail temporal</h3><p>Hasta que el primer test E2E no empezó a pasar, el guardrail era manual. Pero no era “probar un par de cosas y ya”: era un manual testing dirigido y repetible, siempre igual, para detectar regresiones rápido.</p><p>Un patrón típico era:</p><ul><li>disparar un webhook simulado en dev, con Postman,</li><li>confirmar que el pedido entra,</li><li>confirmar que atraviesa los estados esperados,</li><li>y revisar logs/DB lo justo para saber que el flujo no se ha roto.</li></ul><p>La obsesión aquí no era la cobertura, era la <strong>confianza incremental</strong>: después de cada transformación, necesitas una señal rápida de que sigues vivo.</p><h3 id=por-qué-esto-importa-tanto>Por qué esto importa tanto</h3><p>Porque si no haces esta parte bien, el resto del post es teoría bonita. En legacy real, el “cómo llego al primer test” es el tramo más difícil. Y la diferencia entre avanzar y liarla no está en saber hexagonal o DI: está en saber refactorizar con precisión quirúrgica cuando no tienes red.</p><p>Esta disciplina fue la que permitió que el test, poco a poco, dejara de romperse por todas partes… y empezara a avanzar.</p><p>Y cuando por fin el flujo ya no dependía del exterior, apareció el siguiente muro inevitable: <strong>la base de datos</strong>.</p><hr><h2 id=la-base-de-datos-cuando-mockear-deja-de-servir>La base de datos: cuando mockear deja de servir</h2><p>Para este tipo de test E2E, mockear repositorios simplemente no era una opción realista. El comportamiento que queríamos caracterizar dependía directamente de cómo evolucionaba el estado persistido del sistema: qué entidades se creaban, cómo cambiaban de estado, qué registros auxiliares aparecían o desaparecían a lo largo del flujo. Todo eso forma parte del comportamiento real del sistema y no puede simularse con dobles sin perder fidelidad.</p><p>El enfoque fue asumir desde el principio que el test necesitaba una <strong>base de datos real</strong>, pero bajo control total.</p><h3 id=una-base-de-datos-dedicada-no-la-de-dev>Una base de datos dedicada, no “la de dev”</h3><p>El primer paso fue crear una base de datos <strong>exclusiva para tests</strong>, separada explícitamente de desarrollo y, por supuesto, de producción. No era una copia viva, sino un entorno preparado específicamente para ejecutar flujos completos de forma repetible.</p><p>Las reglas eran claras:</p><ul><li>mismo esquema que desarrollo, sin atajos,</li><li>datos semilla inspirados en producción,</li><li>información sensible anonimizada,</li><li>y la capacidad de resetear el estado antes de cada ejecución.</li></ul><p>El esquema se definía de forma explícita mediante un <code>schema.sql</code> con el DDL real. ¿Por qué? Simplemente porque, en proyectos legacy como este, las migraciones a veces cuentan una historia distinta a la de la base de datos real, así que el único punto de partida fiable era el esquema tal y como existía en ese momento, extraído directamente de la base de datos de producción.</p><h3 id=carga-de-datos-iniciales-fixtures-mínimos>Carga de datos iniciales (fixtures mínimos)</h3><p>Sobre ese esquema se cargaba un conjunto de datos semilla muy deliberado. No se trataba de replicar producción, sino de tener <strong>el mínimo conjunto de datos necesario</strong> para que el flujo pudiera ejecutarse de forma realista:</p><ul><li>una conexión activa,</li><li>uno o dos productos,</li><li>configuraciones mínimas para reglas y proveedores,</li><li>y cualquier entidad estrictamente necesaria para que el flujo no fallara por motivos triviales.</li></ul><p>Estos datos se cargaban siempre de la misma forma, al inicio del test o del suite, de manera que el entorno fuera completamente determinista.</p><h3 id=reset-controlado-qué-se-borra-y-qué-no>Reset controlado: qué se borra y qué no</h3><p>Antes de cada ejecución del test, el estado variable de la base de datos se reseteaba de forma explícita. Pero aquí hubo que ser cuidadosos: <strong>no todo se borra</strong>.</p><p>La estrategia fue distinguir entre:</p><ul><li><strong>tablas de referencia</strong>: configuración, catálogos, datos base → se mantienen.</li><li><strong>tablas de estado</strong>: pedidos, logs, intentos, eventos → se limpian.</li></ul><p>En la práctica, el reset consistía en truncar un conjunto muy concreto de tablas, siempre las mismas, y en un orden controlado. Nada de “DROP ALL” ni resets genéricos.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>loadSql</span>($this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>conn</span>, <span style=color:#66d9ef>__DIR__</span><span style=color:#f92672>.</span><span style=color:#e6db74>&#39;/DbSeed/999_reset.sql&#39;</span>);
</span></span><span style=display:flex><span>$this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>loadSql</span>($this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>conn</span>, <span style=color:#66d9ef>__DIR__</span><span style=color:#f92672>.</span><span style=color:#e6db74>&#39;/DbSeed/000_baseline.sql&#39;</span>);
</span></span></code></pre></div><h3 id=guardrail-asegurarse-de-que-nunca-reseteas-donde-no-debes>Guardrail: asegurarse de que nunca reseteas donde no debes</h3><p>Este punto es crítico y merece mencionarse explícitamente.</p><p>Antes de ejecutar cualquier reset, el test verificaba una condición de seguridad en la base de datos: una <strong>tabla o valor canary</strong> que solo existe en la base de datos de tests. Si esa comprobación fallaba, el test abortaba inmediatamente.</p><p>Conceptualmente:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> value <span style=color:#66d9ef>FROM</span> test_canary;
</span></span><span style=display:flex><span><span style=color:#75715e>-- debe devolver algo como: &#34;SAFE_TO_RESET&#34;
</span></span></span></code></pre></div><p>Si esa fila no existe o no contiene el valor esperado, el reset <strong>no se ejecuta</strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>assertTestEnvironment</span>();
</span></span><span style=display:flex><span>$this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>assertTestCanaryExists</span>($this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>conn</span>);
</span></span></code></pre></div><p>Este guardrail evita errores catastróficos del tipo “he lanzado los tests contra la base de datos equivocada”, que en sistemas legacy no son una hipótesis teórica, sino un riesgo real.</p><h3 id=resultado-un-entorno-reproducible-y-predecible>Resultado: un entorno reproducible y predecible</h3><p>Con esta configuración, cada ejecución del test empezaba desde un estado conocido y terminaba con un estado completamente controlado. El flujo crítico podía ejecutarse de principio a fin, siempre bajo las mismas condiciones, sin dependencia de ejecuciones anteriores ni de efectos colaterales.</p><p>En ese punto, por primera vez, el sistema dejaba de ser una caja negra impredecible y pasaba a ser algo <strong>ejecutable y observable bajo demanda</strong>.</p><p>Y justo ahí, cuando ya tienes el flujo ejecutándose de forma determinista, aparece la siguiente pregunta inevitable:
¿cómo comprobamos que lo que ha pasado es “lo correcto” sin escribir tests frágiles?</p><hr><h2 id=hasta-aquí-solo-hemos-preparado-el-terreno>Hasta aquí solo hemos preparado el terreno</h2><p>En este punto todavía no hemos validado nada. Solo hemos conseguido algo que antes no existía: <strong>ejecutar un flujo crítico completo bajo control</strong>.</p><p>No hemos hablado aún de:</p><ul><li>cómo verificar resultados complejos,</li><li>cómo comparar estados sin tests frágiles,</li><li>ni cómo evitar que estos tests se conviertan en una carga inmantenible.</li></ul><p>Pero ahora el tablero es otro.</p><p>En el <a href=https://www.ppardalj.com/newsletter/>siguiente post</a> entraremos justo ahí: cómo convertir todo ese comportamiento en un contrato verificable sin que los tests se rompan con cada cambio menor. Ahí es donde este enfoque se vuelve realmente potente… y donde empiezan las decisiones difíciles.</p></article></div><div class=container><div class="row h-100 align-items-center"><div class="col-12 text-center"><ul class="tags tags-dark"><li><a href=https://www.exeal.com/tags/legacy/>#legacy</a></li><li><a href=https://www.exeal.com/tags/testing/>#testing</a></li><li><a href=https://www.exeal.com/tags/arquitectura/>#arquitectura</a></li></ul><div class=post-author><img class=rounded-circle src=/images/team/pedro-2025.jpg><div class=post-author-name><h2>Pedro Pardal</h2><p>Founder, Software Craftsman & Technical Coach</p><ul class="social-icons list-inline"><li class=list-inline-item><a target=_blank href=https://twitter.com/ppardalj><img src=/assets/img/blog/social-icons/icon-twitter.svg></a></li><li class=list-inline-item><a target=_blank href=https://www.linkedin.com/in/pedro-pardal-jimena-36764344/><img src=/assets/img/blog/social-icons/icon-linkedin.svg></a></li><li class=list-inline-item><a target=_blank href=https://github.com/ppardalj><img src=/assets/img/blog/social-icons/icon-github.svg></a></li><li class=list-inline-item><a target=_blank href=mailto:pedro.pardal@exeal.com><img src=/assets/img/blog/social-icons/icon-email.svg></a></li></ul></div></div><div class=addthis_inline_share_toolbox></div></div></div></div></section><footer class=black><div class=container><div class="row align-items-center"><div class="col-lg-6 text-lg-left"><a href=/><img src=/assets/img/logo-exeal-footer.svg alt=Exeal></a><p><a href=/jobs/extreme-programming-coach/>Empleo</a> |
<a href=/legal/legal-notice/>Aviso legal</a> |
<a href=/legal/cookie-policy/>Política de cookies</a> |
<a href=/legal/privacy-policy/>Política de privacidad</a></p></div><div class="col-lg-6 social-media"><ul class="list-inline text-lg-right mt-3 mt-lg-0"><li class=list-inline-item><a target=_blank href=https://x.com/exeal><img src=/assets/img/social/twitter.svg></a></li><li class=list-inline-item><a target=_blank href=https://www.linkedin.com/company/exeal/><img src=/assets/img/social/linkedin.svg></a></li><li class=list-inline-item><a target=_blank href=https://www.youtube.com/channel/UCxVspi-mashFr1RPGxSxEPA><img src=/assets/img/social/youtube.svg></a></li><li class=list-inline-item><a target=_blank href=https://github.com/exeal-es><img src=/assets/img/social/github.svg></a></li><li class=list-inline-item><a target=_blank href=mailto:hola@exeal.com><img src=/assets/img/social/email.svg></a></li></ul></div></div></div></footer><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><script src=/assets/js/scroll.js></script><script src=/assets/js/redirect.js></script><script src=/assets/js/console.js></script><script src=/assets/js/carousel-scroll.js></script><script>function loadScript(e){var n=document.getElementsByTagName("head")[0],t=document.createElement("script");t.type="text/javascript",t.src="https://tracker.metricool.com/resources/be.js",t.onreadystatechange=e,t.onload=e,n.appendChild(t)}loadScript(function(){beTracker.t({hash:"45d30dfb71957d625ad900e4772a2d6a"})})</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f2bf2edad69c454"></script></body></html>