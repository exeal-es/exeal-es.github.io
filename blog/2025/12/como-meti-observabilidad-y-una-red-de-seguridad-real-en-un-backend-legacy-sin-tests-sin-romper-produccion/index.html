<!doctype html><html lang=es><head><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-TQGN65PV")</script><meta charset=utf-8><title>Cómo metí observabilidad y una red de seguridad real en un backend legacy sin tests (sin romper producción) | Exeal</title>
<meta name=description content="Cómo introducir observabilidad y una red de seguridad real en un backend legacy sin tests, usando structured logging, trazabilidad end-to-end y approval testing sobre flujos críticos"><meta name=author content="Exeal"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:url" content="https://www.exeal.com/blog/2025/12/como-meti-observabilidad-y-una-red-de-seguridad-real-en-un-backend-legacy-sin-tests-sin-romper-produccion/"><meta property="og:site_name" content="Exeal"><meta property="og:title" content="Cómo metí observabilidad y una red de seguridad real en un backend legacy sin tests (sin romper producción)"><meta property="og:description" content="Cómo introducir observabilidad y una red de seguridad real en un backend legacy sin tests, usando structured logging, trazabilidad end-to-end y approval testing sobre flujos críticos"><meta property="og:locale" content="es"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-12-20T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-20T00:00:00+00:00"><meta property="article:tag" content="Legacy"><meta property="article:tag" content="Observabilidad"><meta property="og:image" content="https://www.exeal.com/images/blog/posts/programador.jpg"><meta itemprop=name content="Cómo metí observabilidad y una red de seguridad real en un backend legacy sin tests (sin romper producción)"><meta itemprop=description content="Cómo introducir observabilidad y una red de seguridad real en un backend legacy sin tests, usando structured logging, trazabilidad end-to-end y approval testing sobre flujos críticos"><meta itemprop=datePublished content="2025-12-20T00:00:00+00:00"><meta itemprop=dateModified content="2025-12-20T00:00:00+00:00"><meta itemprop=wordCount content="1154"><meta itemprop=image content="https://www.exeal.com/images/blog/posts/programador.jpg"><meta itemprop=keywords content="Legacy,Observabilidad"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.exeal.com/images/blog/posts/programador.jpg"><meta name=twitter:title content="Cómo metí observabilidad y una red de seguridad real en un backend legacy sin tests (sin romper producción)"><meta name=twitter:description content="Cómo introducir observabilidad y una red de seguridad real en un backend legacy sin tests, usando structured logging, trazabilidad end-to-end y approval testing sobre flujos críticos"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><link rel=stylesheet href=https://www.exeal.com/scss/main.css><link rel=stylesheet href=https://www.exeal.com/scss/hero.css><link rel=icon type=image/png href=/assets/img/favicon.png><link rel=apple-touch-icon href=/assets/img/apple-touch-icon.png><script type=text/javascript id=hs-script-loader async defer src=//js.hs-scripts.com/8231847.js></script><link rel=stylesheet type=text/css href=https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.css><meta name=facebook-domain-verification content="xwbugjbpmp2jwy1y6mzdhe6ga267uz"><script>!function(e,t,n,s,o,i,a){if(e.fbq)return;o=e.fbq=function(){o.callMethod?o.callMethod.apply(o,arguments):o.queue.push(arguments)},e._fbq||(e._fbq=o),o.push=o,o.loaded=!0,o.version="2.0",o.queue=[],i=t.createElement(n),i.async=!0,i.src=s,a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(i,a)}(window,document,"script","https://connect.facebook.net/en_US/fbevents.js"),fbq("init","417415780749470"),fbq("track","PageView")</script><noscript><img height=1 width=1 style=display:none src="https://www.facebook.com/tr?id=417415780749470&ev=PageView&noscript=1"></noscript><script>(function(e,t,n,s,o,i){e.hj=e.hj||function(){(e.hj.q=e.hj.q||[]).push(arguments)},e._hjSettings={hjid:5031744,hjsv:6},o=t.getElementsByTagName("head")[0],i=t.createElement("script"),i.async=1,i.src=n+e._hjSettings.hjid+s+e._hjSettings.hjsv,o.appendChild(i)})(window,document,"https://static.hotjar.com/c/hotjar-",".js?sv=")</script><link rel=stylesheet href=https://www.exeal.com/scss/blog.css><link rel=stylesheet href=https://www.exeal.com/scss/hero.css></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-TQGN65PV" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><nav class="navbar navbar-light navbar-expand-lg navbar-shrink"><div class=container><div class="d-flex flex-row"><a href=/ class=navbar-brand><img src=/assets/img/logo-exeal-header-black.svg alt=Exeal>
</a><a href=/blog/ class=navbar-brand><img src=/assets/img/blog/logo-blog.svg alt=Blog></a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarTogglerDemo01 aria-controls=navbarTogglerDemo01 aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarTogglerDemo01><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/eventos/>Próximos Eventos</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownrecursos role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Recursos</a><div class=dropdown-menu aria-labelledby=navbarDropdownrecursos><a class=dropdown-item href=/recursos/checklist-equipos-de-alto-rendimiento/>Equipos de alto rendimiento</a>
<a class=dropdown-item href=/recursos/habla-el-idioma-del-negocio/>Habla el idioma del negocio</a>
<a class=dropdown-item href=/hacia-la-excelencia/>Comunidad de práctica</a>
<a class=dropdown-item href=/katas/>Katas de programación</a>
<a class=dropdown-item href=/blog/>Blog</a></div></li><li class=nav-item><a class="nav-link nav-button" href=/>Cursos</a></li></ul></div></div></nav><header class="hero hero-bg-img" style=background-image:url(/images/blog/posts/programador.jpg)><div class="hero-bg-img-mask bg-mask"><div class="container h-100"><div class="row h-100 align-items-center"><div class="col-12 text-center"><ul class="tags tags-light"><li><a href=https://www.exeal.com/tags/legacy/>#legacy</a></li><li><a href=https://www.exeal.com/tags/observabilidad/>#observabilidad</a></li></ul><h1><span class=underline>Cómo metí observabilidad y una red de seguridad real en un backend legacy sin tests (sin romper producción)</span></h1><h2>Pedro Pardal</h2><p class=date>2025/12/20</p><p><a data-scroll=sect-body href=#><img class=arrow-down src=/assets/img/arrow-down-secondary.svg></a></p></div></div></div></div></header><section id=sect-body><div class=container><article><p>Entré en un backend Symfony en producción con el clásico combo: cero tests, flujos de negocio complejos, mucha automatización (crons + colas), integraciones con terceros y clientes esperando. No era un entorno para “hacer las cosas perfectas”. Era un entorno para <strong>no cargarte nada</strong>, aprender rápido y empezar a recuperar control.</p><p>Mi objetivo de la primera semana no fue “añadir tests”. Fue <strong>hacer el sistema observable</strong>.</p><p>Porque en legacy, cuando no tienes red, el primer problema no es la calidad del código. Es que <strong>no puedes explicar qué está pasando</strong>.</p><h3 id=el-problema-real-no-era-el-bug-era-la-falta-de-una-historia>El problema real: no era el bug, era la falta de una historia</h3><p>Había pedidos atascados y reintentos interminables. Pero el dolor de verdad era otro:</p><ul><li>No podías seguir un pedido end-to-end sin abrir 5 sitios distintos.</li><li>Los logs no eran consistentes: cada flujo logueaba lo que quería, como quería.</li><li>Había ruido (errores que no eran errores) y silencio (fallos que no se veían).</li><li>Con colas y crons, el pedido “saltaba” entre procesos y perdías contexto.</li></ul><p>Cuando estás así, los tests son difíciles por una razón simple: <strong>no sabes qué estás testando</strong>. Lo primero es poder responder: “para este pedido concreto, ¿qué pasos ha dado el sistema, en qué orden, y por qué?”.</p><h3 id=principio-guía-tocar-código-con-el-mínimo-riesgo-posible>Principio guía: tocar código con el mínimo riesgo posible</h3><p>En la fase 1 mi regla fue: <strong>instrumentar, no reescribir</strong>.</p><p>Eso significa:</p><ul><li>Nada de refactors grandes.</li><li>Nada de “ya que estoy” limpiando lógica.</li><li>Cambios locales, mecánicos, reversibles.</li><li>Si el cambio no se puede revertir rápido, no entra.</li></ul><p>La idea: mejorar visibilidad sin cambiar comportamiento.</p><h2 id=fase-1--observabilidad-structured-logging--campos-canónicos>Fase 1 — Observabilidad: structured logging + campos canónicos</h2><h3 id=1-structured-logging-json-como-contrato>1) Structured logging (JSON) como contrato</h3><p>En vez de logs “bonitos”, busqué logs “útiles”.</p><ul><li>JSON por defecto (para parseo, query, agregación).</li><li>Mensajes cortos.</li><li>Contexto siempre presente.</li></ul><p>Ejemplo de estructura (conceptual):</p><ul><li><code>event</code>: nombre canónico del evento (ej: <code>order.process.started</code>)</li><li><code>order_id</code>: ID interno (tu “primary key” de verdad)</li><li><code>customer_id</code>: si aplica</li><li><code>connection_id</code> / <code>store_id</code>: si aplica</li><li><code>flow</code>: nombre del flujo (“new_order”, “post_kyc_validation”, “capture”, etc.)</li><li><code>step</code>: paso dentro del flujo</li><li><code>correlation_id</code>: para seguir saltos entre cron/worker/webhook</li><li><code>duration_ms</code>: cuando tenga sentido</li><li><code>result</code>: ok/fail + motivo</li></ul><p>No necesitas todos desde el minuto 1. Pero sí necesitas <strong>un estándar</strong>.</p><h3 id=2-campos-canónicos-order_id-y-customer_id-como-religión>2) Campos canónicos: <code>order_id</code> y <code>customer_id</code> como religión</h3><p>Esto es lo que más impacto tuvo: <strong>que todos los logs importantes tuvieran <code>order_id</code></strong>.</p><p>Con sistemas asíncronos, si no tienes un identificador canónico:</p><ul><li>no puedes reconstruir historias,</li><li>no puedes comparar casos,</li><li>no puedes automatizar alertas,</li><li>no puedes testear trazas.</li></ul><p><code>order_id</code> + <code>customer_id</code> fueron los mínimos. Luego puedes sumar <code>shopify_order_id</code>, <code>payment_method</code>, etc.</p><h3 id=3-trazar-todos-los-flujos-de-negocio-críticos>3) Trazar todos los flujos de negocio críticos</h3><p>Aquí fui muy explícito: quería trazas en los puntos donde el pedido cambia de “fase” o de “responsable”.</p><p>Por ejemplo (conceptual, no exacto):</p><ul><li>Entrada de pedido (webhook / cron pull)</li><li>Sync / refresh de datos desde Shopify</li><li>Evaluación antifraude / reglas</li><li>Disparo de KYC / post-KYC</li><li>Encolado a procesamiento</li><li>Procesamiento de líneas (allocación / compra)</li><li>Envío de email</li><li>Captura del pago</li><li>Fulfillment / cierre</li></ul><p>Los puntos de instrumentación típicos:</p><ul><li>Handlers de Messenger (porque son saltos de proceso)</li><li>Commands de cron (porque son triggers repetitivos)</li><li>Servicios “núcleo” donde pasan cosas irreversibles (captura, compra a vendor, email)</li></ul><h3 id=4-riesgo-controlado-instrumentar-sin-alterar-lógica>4) Riesgo controlado: instrumentar sin alterar lógica</h3><p>Para no meterme en un “refactor disfrazado”, mi criterio fue:</p><ul><li>Cambiar solo llamadas a logger + contexto.</li><li>Evitar tocar condiciones / branching.</li><li>Si necesito contexto, lo calculo de forma local (p.ej., leer <code>$order->getId()</code>), sin cambiar flujos.</li></ul><p>Es sorprendente lo mucho que mejora el sistema con solo esto.</p><h2 id=fase-2--preparar-tests-para-flujos-críticos-sin-volverte-loco>Fase 2 — Preparar tests para flujos críticos sin volverte loco</h2><p>Una vez que puedes ver un pedido end-to-end, puedes hacer algo que en legacy es oro:</p><p><strong>convertir una traza real en un test de regresión.</strong></p><p>Pero no con unit tests tradicionales. Con una estrategia que funciona especialmente bien en sistemas asíncronos: <strong>approval testing / snapshot testing</strong>.</p><p>La idea:</p><ul><li>Ejecutas un flujo real (controlado).</li><li>Capturas el output observable (logs estructurados + estado final).</li><li>Guardas eso como “foto”.</li><li>Si cambia, alguien decidió que era correcto o se rompió algo.</li></ul><h3 id=5-approval-testing-sobre-logs-una-foto-de-un-pedido-end-to-end>5) Approval testing sobre logs: una foto de un pedido end-to-end</h3><p>La clave aquí es diseñar el “artefacto verificable”. En mi caso:</p><ul><li>Un <strong>snapshot de logs</strong> del flujo crítico (filtrados por <code>order_id</code> / <code>correlation_id</code>)</li><li>Y un <strong>snapshot del estado final</strong> relevante en base de datos</li></ul><p>Eso te permite detectar:</p><ul><li>Cambios en el orden de pasos</li><li>Pasos que desaparecen</li><li>Errores que antes no ocurrían</li><li>Estados finales inesperados</li></ul><p>Y lo mejor: sin entender toda la lógica interna todavía.</p><h3 id=6-dobles-en-los-bordes-no-testear-terceros-testear-tu-sistema>6) Dobles en los bordes: no testear terceros, testear tu sistema</h3><p>Para que un E2E sea estable necesitas controlar bordes:</p><ul><li>APIs de terceros (Shopify, PayPal/Klarna, KYC, vendors)</li><li>Message queues / transport</li><li>Reloj/tiempo (backoffs, expiraciones)</li></ul><p>Estrategia:</p><ul><li>Dobles (stubs/fakes) en integraciones externas.</li><li>Mantener “real” todo lo que sea tu código: servicios, handlers, repos, persistencia.</li></ul><p>Esto te da un E2E que no depende de internet ni de estados de sandbox aleatorios.</p><h3 id=7-bbdd-con-docker-reproducibilidad-antes-que-pureza>7) BBDD con Docker: reproducibilidad antes que pureza</h3><p>Montar una MySQL (o la que uses) en Docker te da:</p><ul><li>schema consistente</li><li>fixtures deterministas</li><li>reset rápido entre tests</li><li>posibilidad de ejecutar local y en CI</li></ul><p>No busco el test perfecto: busco el test que corre siempre.</p><h3 id=8-end-to-end-sí-pero-solo-de-nuestro-código>8) “End-to-end sí, pero solo de nuestro código”</h3><p>Esto es importante: “E2E” no significa “pegarle a todo lo externo”.</p><p>Significa:</p><ul><li>atravieso el flujo completo dentro de mi sistema,</li><li>pero en los bordes tengo dobles,</li><li>y verifico outputs observables (logs + estado).</li></ul><p>Si mañana PayPal cambia algo, no me rompe el test. Si yo rompo mi flujo, sí.</p><h2 id=la-mecánica-del-safety-net-detectar-mínimos-cambios-y-decidir-rápido>La mecánica del safety net: detectar mínimos cambios y decidir rápido</h2><p>Aquí está el valor real para un CTO: <strong>control del riesgo de cambios</strong>.</p><p>La dinámica es:</p><ol><li><p>Corro el test del flujo crítico</p></li><li><p>Si el snapshot cambia:</p><ul><li>Si era esperable: apruebo el nuevo snapshot</li><li>Si no era esperable: revert o investigo antes de mergear</li></ul></li></ol><p>Esto convierte el trabajo en algo mucho más seguro:</p><ul><li>cambios pequeños,</li><li>feedback rápido,</li><li>regresiones detectadas por “historia” y no por asserts frágiles.</li></ul><p>Y una vez que tienes esta red, puedes empezar a mejorar el sistema sin miedo.</p><h2 id=paso-a-paso-cómo-evoluciona-después>Paso a paso: cómo evoluciona después</h2><p>Una vez tienes trazas y tests de snapshot, el camino natural es ir subiendo la calidad:</p><ol><li><p>Mantener el test E2E “gordo” como red de seguridad</p></li><li><p>Ir extrayendo tests más finos:</p><ul><li>unit tests donde haya lógica pura y estable</li><li>integration tests por componentes</li></ul></li><li><p>Limpiar el logging:</p><ul><li>niveles correctos</li><li>menos ruido</li><li>eventos más canónicos</li></ul></li><li><p>Refactors graduales con protección</p></li></ol><blockquote><p>La paradoja: los tests buenos llegan cuando ya entiendes.
Y entiendes cuando observas.</p></blockquote><h2 id=cierre-la-idea-contraria-pero-práctica>Cierre: la idea contraria (pero práctica)</h2><p>En un legacy en producción, <strong>la observabilidad no es un extra</strong>. Es el primer mecanismo de control.</p><p>Primero haces el sistema explicable.
Luego lo haces comprobable.</p><p>Si estás heredando un backend sin tests y con incidentes reales, mi recomendación es esta:</p><ul><li>Instrumenta primero.</li><li>Convierte la realidad (trazas + estado) en un safety net con snapshots.</li><li>Y desde ahí, limpia y afina con tests de grano fino.</li></ul><p>No es elegante. Es efectivo. Y te deja dormir.</p></article></div><div class=container><div class="row h-100 align-items-center"><div class="col-12 text-center"><ul class="tags tags-dark"><li><a href=https://www.exeal.com/tags/legacy/>#legacy</a></li><li><a href=https://www.exeal.com/tags/observabilidad/>#observabilidad</a></li></ul><div class=post-author><img class=rounded-circle src=/images/team/pedro-2025.jpg><div class=post-author-name><h2>Pedro Pardal</h2><p>Founder, Software Craftsman & Technical Coach</p><ul class="social-icons list-inline"><li class=list-inline-item><a target=_blank href=https://twitter.com/ppardalj><img src=/assets/img/blog/social-icons/icon-twitter.svg></a></li><li class=list-inline-item><a target=_blank href=https://www.linkedin.com/in/pedro-pardal-jimena-36764344/><img src=/assets/img/blog/social-icons/icon-linkedin.svg></a></li><li class=list-inline-item><a target=_blank href=https://github.com/ppardalj><img src=/assets/img/blog/social-icons/icon-github.svg></a></li><li class=list-inline-item><a target=_blank href=mailto:pedro.pardal@exeal.com><img src=/assets/img/blog/social-icons/icon-email.svg></a></li></ul></div></div><div class=addthis_inline_share_toolbox></div></div></div></div></section><footer class=black><div class=container><div class="row align-items-center"><div class="col-lg-6 text-lg-left"><a href=/><img src=/assets/img/logo-exeal-footer.svg alt=Exeal></a><p><a href=/jobs/extreme-programming-coach/>Empleo</a> |
<a href=/legal/legal-notice/>Aviso legal</a> |
<a href=/legal/cookie-policy/>Política de cookies</a> |
<a href=/legal/privacy-policy/>Política de privacidad</a></p></div><div class="col-lg-6 social-media"><ul class="list-inline text-lg-right mt-3 mt-lg-0"><li class=list-inline-item><a target=_blank href=https://x.com/exeal><img src=/assets/img/social/twitter.svg></a></li><li class=list-inline-item><a target=_blank href=https://www.linkedin.com/company/exeal/><img src=/assets/img/social/linkedin.svg></a></li><li class=list-inline-item><a target=_blank href=https://www.youtube.com/channel/UCxVspi-mashFr1RPGxSxEPA><img src=/assets/img/social/youtube.svg></a></li><li class=list-inline-item><a target=_blank href=https://github.com/exeal-es><img src=/assets/img/social/github.svg></a></li><li class=list-inline-item><a target=_blank href=mailto:hola@exeal.com><img src=/assets/img/social/email.svg></a></li></ul></div></div></div></footer><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><script src=/assets/js/scroll.js></script><script src=/assets/js/redirect.js></script><script src=/assets/js/console.js></script><script src=/assets/js/carousel-scroll.js></script><script>function loadScript(e){var n=document.getElementsByTagName("head")[0],t=document.createElement("script");t.type="text/javascript",t.src="https://tracker.metricool.com/resources/be.js",t.onreadystatechange=e,t.onload=e,n.appendChild(t)}loadScript(function(){beTracker.t({hash:"45d30dfb71957d625ad900e4772a2d6a"})})</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f2bf2edad69c454"></script></body></html>